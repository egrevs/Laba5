Laba5 — Консольное приложение для управления коллекцией работников
===============================================================

Приложение позволяет хранить коллекцию работников (`Worker`) в `HashMap<Long, Worker>`, выполнять команды над коллекцией из консоли и из скриптов, а также сохранять/загружать данные в/из JSON файла.

Возможности
-----------
- Хранение элементов в `HashMap<Long, Worker>`
- Ввод данных интерактивно и из скрипта (файл)
- Команды:
  - `help` — список команд
  - `info` — сведения о коллекции
  - `show` — вывод всех элементов коллекции
  - `insert <key>` — добавить сотрудника по ключу
  - `update <id>` — обновить сотрудника по id
  - `remove_key <key>` — удалить по ключу
  - `clear` — очистить коллекцию
  - `save` — сохранить в файл
  - `execute_script <file>` — выполнить команды из файла
  - `remove_greater_key <key>` — удалить все элементы с ключом больше заданного
  - `remove_all_by_status <status>` — удалить по статусу
  - `replace_if_greater <key>` — заменить, если новый элемент больше существующего
  - `count_less_than_salary <salary>` — посчитать сотрудников с зарплатой меньше заданной

Стек
----
- Java
- Gson (JSON сериализация/десериализация)

Структура проекта (основные пакеты)
-----------------------------------
- `itmo.studying.data` — модели (`Worker`, `Coordinates`, `Organization`, `Position`, `Status`)
- `itmo.studying.commands` — реализации команд и базовые интерфейсы
- `itmo.studying.utils` — инфраструктура: консоль, менеджеры, работа с файлами, запрос значений
- `itmo.studying.exceptions` — кастомные исключения

Запуск
------
1. Установите переменную окружения с путём к JSON файлу (минимум пустой файл):
   - macOS/Linux (zsh):
     ```bash
     export LABA="/Users/egrevs/studying/Laba5/test.json"
     ```
   - В IntelliJ IDEA: Run → Edit Configurations → Environment → Environment variables → добавьте `LABA=/Users/egrevs/studying/Laba5/test.json`.
2. Соберите и запустите проект (через IDEA или `mvn package`/`java -jar`).
3. В интерактивной консоли вводите команды, например:
   ```
   help
   insert 1
   show
   save
   ```

Скриптовый режим
----------------
- Команда `execute_script <path>` включает режим чтения команд и ответов из файла.
- Пример файла скрипта: `demo.script` (идёт в репозитории):
  ```
  insert 1
  John Doe
  10
  20.5
  50000
  BAKER
  HIRED
  Acme Corp
  1000000
  200
  show
  count_less_than_salary 60000
  group_counting_by_name
  save
  ```
- Запуск:
  ```
  execute_script /Users/egrevs/studying/Laba5/demo.script
  ```

Сохранение и загрузка (JSON)
----------------------------
- Чтение/запись реализованы в `FileManager` (Gson). Путь берётся из переменной окружения `LABA`.
- Пустой/пробельный JSON корректно обрабатывается (возвращается пустая коллекция).
- Для `LocalDate` используется адаптер (строка вида `yyyy-MM-dd`).

Генерация ID (автоинкремент)
----------------------------
- В `Worker` используется статический `AtomicInteger` инициализации ID в конструкторе.
- После загрузки коллекции в `CollectionManager.loadCollection()` вычисляется максимальный `id` среди элементов и вызывается `Worker.resetIdCounter(maxId)`. Это гарантирует, что следующий созданный `Worker` получит `id = maxId + 1` даже после перезапуска.

Ввод данных и валидация
------------------------
- Ввод полей делается через `WorkerRequester`.
- В интерактивном режиме на неверный ввод запрашивается повтор.
- В скриптовом режиме некорректный ввод приводит к ошибке выполнения скрипта.
- Для вопросов `y/n` используется сравнение без учета регистра (`equalsIgnoreCase`).

Примечания по разработке
------------------------
- Обработка команд происходит в `Console.launchCommand`, диспетчеризация — через `CommandManager`.
- Команда `execute_script` вызывает `Console.scriptMode`.
- Исключения документированы и используются для валидации и управления потоком выполнения.
 
Архитектура
-----------
- `App` — точка входа: создаёт `FileManager`, `CollectionManager`, `WorkerRequester`, команды и `CommandManager`, затем `Console` и запускает интерактивный режим.
- `Console` — парсит пользовательский ввод/скрипт и вызывает `CommandManager`. В скриптовом режиме подменяет `Scanner` в `WorkerRequester` на файловый и возвращает назад после исполнения.
- `CommandManager` — агрегирует все `Command`, хранит историю, вызывает `execute()` у конкретной команды.
- `commands/*` — реализации команд; каждая команда через внедрённые зависимости работает с `CollectionManager`/`WorkerRequester`.
- `CollectionManager` — операции над коллекцией (`HashMap<Long, Worker>`), сохранение/загрузка через `FileManager`.
- `FileManager` — JSON (де)сериализация коллекции с помощью Gson + адаптер `LocalDate`.
- `WorkerRequester` — диалоговый ввод и чтение ответов из файла (в `fileMode`).
- `data/*` — модели предметной области.
- `exceptions/*` — прикладные исключения для валидации и управления потоком.


Паттерны и фасады
------------------
- Facade — `CommandManager` выступает фасадом над множеством команд: внешний код не знает о конкретных реализациях, вызывает высокоуровневые методы (`insert`, `save`, `update` и т.д.).
- Facade/Gateway — `CollectionManager` инкапсулирует работу с хранилищем (`HashMap`) и предоставляет удобные операции; `FileManager` — фасад к файловой системе и JSON.
- Controller — `Console` играет роль контроллера ввода/вывода и маршрутизации команд.
- Strategy — каждую команду можно рассматривать как стратегию выполнения определённого действия (реализация интерфейса `Command`).


 
